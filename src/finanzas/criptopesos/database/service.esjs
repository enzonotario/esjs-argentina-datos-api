importar { createClient } desde '@libsql/client'
importar { MigrationRunner } desde './migrations/migration-runner.esjs'

exportar clase CriptopesosDatabaseService {
  constructor(url, authToken) {
    ambiente.db = createClient({
      url,
      authToken,
    })
    ambiente.migrationRunner = crear MigrationRunner(ambiente.db)
  }

  asincrono initialize() {
    esperar ambiente.migrationRunner.runPendingMigrations()
  }

  asincrono insertCriptopeso(token, entidad, tna, timestamp) {
    esperar ambiente.db.execute({
      sql: `
        INSERT INTO criptopesos (token, entidad, tna, timestamp)
        VALUES (?, ?, ?, ?)
      `,
      args: [token, entidad, tna, timestamp],
    })
  }

  asincrono getLatestCriptopesoByEntity(token, entidad) {
    const resultado = esperar ambiente.db.execute({
      sql: `
        SELECT id, token, entidad, tna, timestamp
        FROM criptopesos
        WHERE token = ? AND entidad = ?
        ORDER BY timestamp DESC, created_at DESC
        LIMIT 1
      `,
      args: [token, entidad],
    })
    si (resultado.rows.longitud === 0) {
      retornar nulo
    }
    const row = resultado.rows[0]
    retornar {
      id: row.id,
      token: row.token,
      entidad: row.entidad,
      tna: row.tna,
      timestamp: row.timestamp,
    }
  }

  asincrono getAllLatestCriptopesos() {
    const resultado = esperar ambiente.db.execute({
      sql: `
        SELECT c.*
        FROM criptopesos c
        INNER JOIN (
          SELECT token, entidad, MAX(timestamp) AS max_timestamp
          FROM criptopesos
          GROUP BY token, entidad
        ) latest ON c.token = latest.token 
          AND c.entidad = latest.entidad 
          AND c.timestamp = latest.max_timestamp
        ORDER BY c.entidad, c.token
      `,
    })
    retornar resultado.rows.mapear(row => ({
      id: row.id,
      token: row.token,
      entidad: row.entidad,
      tna: row.tna,
      timestamp: row.timestamp,
    }));
  }

  close() {
    ambiente.db.close()
  }
}
