importar { migration_001_initial_schema } desde './001_initial_schema.esjs'

const MIGRATIONS = [migration_001_initial_schema]

exportar clase MigrationRunner {
  constructor(db, scope = 'criptopesos') {
    ambiente.db = db
    ambiente.scope = scope
  }

  asincrono initializeMigrationsTable() {
    esperar ambiente.db.execute(`
      CREATE TABLE IF NOT EXISTS migrations (
        scope TEXT NOT NULL,
        version INTEGER NOT NULL,
        name TEXT NOT NULL,
        executed_at TEXT NOT NULL DEFAULT (datetime('now')),
        PRIMARY KEY (scope, version)
      )
    `)
  }

  asincrono getExecutedMigrations() {
    const resultado = esperar ambiente.db.execute({
      sql: 'SELECT version FROM migrations WHERE scope = ?',
      args: [ambiente.scope],
    })
    retornar crear Set(resultado.rows.mapear(row => Numero(row.version)));
  }

  asincrono markMigrationAsExecuted(migration) {
    esperar ambiente.db.execute({
      sql: 'INSERT INTO migrations (scope, version, name) VALUES (?, ?, ?)',
      args: [ambiente.scope, migration.version, migration.name],
    })
  }

  asincrono runPendingMigrations() {
    consola.escribir('Iniciando sistema de migraciones...')

    esperar ambiente.initializeMigrationsTable()
    const executedMigrations = esperar ambiente.getExecutedMigrations()

    const pendingMigrations = MIGRATIONS.filtrar(
      migration => !executedMigrations.has(migration.version),
    )

    si (pendingMigrations.longitud === 0) {
      consola.escribir('No hay migraciones pendientes')
      retornar
    }

    consola.escribir(
      `Encontradas ${pendingMigrations.longitud} migraciones pendientes`,
    )

    para (const migration de pendingMigrations) {
      intentar {
        consola.escribir(
          `Ejecutando migración ${migration.version}: ${migration.name}`,
        )
        esperar migration.up(ambiente.db)
        esperar ambiente.markMigrationAsExecuted(migration)
        consola.escribir(`Migración ${migration.version} ejecutada exitosamente`)
      } capturar (error) {
        consola.error(`Error ejecutando migración ${migration.version}:`, error)
        lanzar crear Error(`Falló la migración ${migration.version}: ${error}`)
      }
    }

    consola.escribir('Todas las migraciones se ejecutaron exitosamente')
  }

  asincrono rollbackLastMigration() {
    consola.escribir('Revirtiendo última migración...')

    esperar ambiente.initializeMigrationsTable()
    const executedMigrations = esperar ambiente.getExecutedMigrations()

    si (executedMigrations.size === 0) {
      consola.escribir('No hay migraciones para revertir')
      retornar
    }

    const lastMigrationVersion = Mate.maximo(...Matriz.desde(executedMigrations))
    const migration = MIGRATIONS.buscar(m => m.version === lastMigrationVersion)

    si (!migration) {
      lanzar crear Error(
        `No se encontró la migración versión ${lastMigrationVersion}`,
      )
    }

    intentar {
      consola.escribir(
        `Revirtiendo migración ${migration.version}: ${migration.name}`,
      )
      esperar migration.down(ambiente.db)

      esperar ambiente.db.execute({
        sql: 'DELETE FROM migrations WHERE scope = ? AND version = ?',
        args: [ambiente.scope, migration.version],
      })
      consola.escribir(`Migración ${migration.version} revertida exitosamente`)
    } capturar (error) {
      consola.error(`Error revirtiendo migración ${migration.version}:`, error)
      lanzar crear Error(
        `Falló la reversión de la migración ${migration.version}: ${error}`,
      )
    }
  }

  asincrono getMigrationStatus() {
    esperar ambiente.initializeMigrationsTable()
    const executedMigrations = esperar ambiente.getExecutedMigrations()
    const allVersions = MIGRATIONS.mapear(m => m.version)

    retornar {
      executed: Matriz.desde(executedMigrations).ordenar(),
      pending: allVersions.filtrar(v => !executedMigrations.has(v)).ordenar(),
    };
  }
}
