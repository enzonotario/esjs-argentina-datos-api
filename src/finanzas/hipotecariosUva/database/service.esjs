importar { createClient } desde '@libsql/client'
importar { MigrationRunner } desde './migrations/migration-runner.esjs'

exportar clase HipotecariosUvaDatabaseService {
  constructor(url, authToken) {
    ambiente.db = createClient({
      url,
      authToken,
    })
    ambiente.migrationRunner = crear MigrationRunner(ambiente.db)
  }

  asincrono initialize() {
    esperar ambiente.migrationRunner.runPendingMigrations()
  }

  asincrono insertTna(entidad, nombreComercial, tna, timestamp) {
    esperar ambiente.db.execute({
      sql: `
        INSERT INTO hipotecarios_uva (entidad, nombreComercial, tna, timestamp)
        VALUES (?, ?, ?, ?)
      `,
      args: [entidad, nombreComercial, tna, timestamp],
    })
  }

  asincrono insertBatchTna(items) {
    si (items.longitud === 0) {
      retornar
    }

    const CHUNK_SIZE = 100
    para (mut i = 0; i < items.longitud; i += CHUNK_SIZE) {
      const chunk = items.rodaja(i, i + CHUNK_SIZE)
      const statements = chunk.mapear(item => ({
        sql: `
          INSERT INTO hipotecarios_uva (entidad, nombreComercial, tna, timestamp)
          VALUES (?, ?, ?, ?)
        `,
        args: [item.entidad, item.nombreComercial, item.tna, item.timestamp],
      }))
      esperar ambiente.db.batch(statements)
    }
  }

  asincrono getLatestTnaByEntidad(entidad) {
    const resultado = esperar ambiente.db.execute({
      sql: `
        SELECT id, entidad, nombreComercial, tna, timestamp
        FROM hipotecarios_uva
        WHERE entidad = ?
        ORDER BY timestamp DESC, created_at DESC
        LIMIT 1
      `,
      args: [entidad],
    })
    si (resultado.rows.longitud === 0) {
      retornar nulo
    }
    const row = resultado.rows[0]
    retornar {
      id: row.id,
      entidad: row.entidad,
      nombreComercial: row.nombreComercial,
      tna: row.tna,
      timestamp: row.timestamp,
    }
  }

  asincrono getAllLatestTna() {
    const resultado = esperar ambiente.db.execute({
      sql: `
        SELECT h.*
        FROM hipotecarios_uva h
        INNER JOIN (
          SELECT entidad, MAX(timestamp) AS max_timestamp
          FROM hipotecarios_uva
          GROUP BY entidad
        ) latest ON h.entidad = latest.entidad 
          AND h.timestamp = latest.max_timestamp
        ORDER BY h.entidad
      `,
    })
    retornar resultado.rows.mapear(row => ({
      id: row.id,
      entidad: row.entidad,
      nombreComercial: row.nombreComercial,
      tna: row.tna,
      timestamp: row.timestamp,
    }));
  }

  close() {
    ambiente.db.close()
  }
}
