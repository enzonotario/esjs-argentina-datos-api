importar { createClient } desde '@libsql/client'
importar { MigrationRunner } desde './migrations/migration-runner.esjs'

exportar clase FciOtrosDatabaseService {
  constructor(url, authToken) {
    ambiente.db = createClient({
      url,
      authToken,
    })
    ambiente.migrationRunner = crear MigrationRunner(
      ambiente.db,
      'fci-otros',
    )
  }

  asincrono initialize() {
    esperar ambiente.migrationRunner.runPendingMigrations()
  }

  asincrono insertFciOtros(fondo, tna, tea, tope, fecha, condiciones, condicionesCorto, timestamp) {
    esperar ambiente.db.execute({
      sql: `
        INSERT INTO fci_otros (fondo, tna, tea, tope, fecha, condiciones, condicionesCorto, timestamp)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `,
      args: [fondo, tna, tea, tope, fecha, condiciones, condicionesCorto, timestamp],
    })
  }

  asincrono getLatestFciOtrosByFondo(fondo) {
    const resultado = esperar ambiente.db.execute({
      sql: `
        SELECT id, fondo, tna, tea, tope, fecha, condiciones, condicionesCorto, timestamp
        FROM fci_otros
        WHERE fondo = ?
        ORDER BY timestamp DESC, created_at DESC
        LIMIT 1
      `,
      args: [fondo],
    })
    si (resultado.rows.longitud === 0) {
      retornar nulo
    }
    const row = resultado.rows[0]
    retornar {
      id: row.id,
      fondo: row.fondo,
      tna: row.tna,
      tea: row.tea,
      tope: row.tope,
      fecha: row.fecha,
      condiciones: row.condiciones,
      condicionesCorto: row.condicionesCorto,
      timestamp: row.timestamp,
    }
  }

  asincrono getAllLatestFciOtros() {
    const resultado = esperar ambiente.db.execute({
      sql: `
        SELECT c.*
        FROM fci_otros c
        INNER JOIN (
          SELECT fondo, MAX(timestamp) AS max_timestamp
          FROM fci_otros
          GROUP BY fondo
        ) latest ON c.fondo = latest.fondo
          AND c.timestamp = latest.max_timestamp
        ORDER BY c.fondo
      `,
    })
    retornar resultado.rows.mapear(row => ({
      id: row.id,
      fondo: row.fondo,
      tna: row.tna,
      tea: row.tea,
      tope: row.tope,
      fecha: row.fecha,
      condiciones: row.condiciones,
      condicionesCorto: row.condicionesCorto,
      timestamp: row.timestamp,
    }));
  }

  asincrono getFciOtrosByFecha(fecha) {
    const resultado = esperar ambiente.db.execute({
      sql: `
        SELECT c.*
        FROM fci_otros c
        INNER JOIN (
          SELECT fondo, MAX(timestamp) AS max_timestamp
          FROM fci_otros
          WHERE fecha = ?
          GROUP BY fondo
        ) latest ON c.fondo = latest.fondo
          AND c.timestamp = latest.max_timestamp
        ORDER BY c.fondo
      `,
      args: [fecha],
    })
    retornar resultado.rows.mapear(row => ({
      id: row.id,
      fondo: row.fondo,
      tna: row.tna,
      tea: row.tea,
      tope: row.tope,
      fecha: row.fecha,
      condiciones: row.condiciones,
      condicionesCorto: row.condicionesCorto,
      timestamp: row.timestamp,
    }));
  }

  asincrono getPenultimoFciOtros() {
    const resultado = esperar ambiente.db.execute({
      sql: `
        SELECT c.*
        FROM fci_otros c
        INNER JOIN (
          SELECT fondo, MAX(timestamp) AS max_timestamp
          FROM fci_otros c2
          WHERE c2.timestamp < (
            SELECT MAX(timestamp)
            FROM fci_otros c3
            WHERE c3.fondo = c2.fondo
          )
          GROUP BY fondo
        ) penultimo ON c.fondo = penultimo.fondo
          AND c.timestamp = penultimo.max_timestamp
        ORDER BY c.fondo
      `,
    })
    retornar resultado.rows.mapear(row => ({
      id: row.id,
      fondo: row.fondo,
      tna: row.tna,
      tea: row.tea,
      tope: row.tope,
      fecha: row.fecha,
      condiciones: row.condiciones,
      condicionesCorto: row.condicionesCorto,
      timestamp: row.timestamp,
    }));
  }

  asincrono getHistorialPorFondo(fondo) {
    const resultado = esperar ambiente.db.execute({
      sql: `
        SELECT id, fondo, tna, tea, tope, fecha, condiciones, condicionesCorto, timestamp
        FROM fci_otros
        WHERE fondo = ?
        ORDER BY timestamp ASC, created_at ASC
      `,
      args: [fondo],
    })
    retornar resultado.rows.mapear(row => ({
      id: row.id,
      fondo: row.fondo,
      tna: row.tna,
      tea: row.tea,
      tope: row.tope,
      fecha: row.fecha,
      condiciones: row.condiciones,
      condicionesCorto: row.condicionesCorto,
      timestamp: row.timestamp,
    }));
  }

  asincrono getAllFondos() {
    const resultado = esperar ambiente.db.execute({
      sql: `
        SELECT DISTINCT fondo
        FROM fci_otros
        ORDER BY fondo
      `,
    })
    retornar resultado.rows.mapear(row => row.fondo);
  }

  close() {
    ambiente.db.close()
  }
}
